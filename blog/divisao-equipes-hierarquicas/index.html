<!DOCTYPE html>
<html lang="pt">

<head>
  
  <link rel="shortcut icon" href="https:&#x2F;&#x2F;igorgcardoso.github.io&#x2F;processed_images&#x2F;avatar.ca59f5fdacb63bbf.png" type="image/png">
  <link rel="icon" href="https:&#x2F;&#x2F;igorgcardoso.github.io&#x2F;processed_images&#x2F;avatar.ca59f5fdacb63bbf.png" type="image/png">

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <meta charset="utf-8">

  <!-- Custom header for users, includes custom css or js here -->
  <title> Igor Cardoso</title>

  
<!-- CSS -->
<link rel="stylesheet" href="https://igorgcardoso.github.io/styles/styles.css" />

    <title>
    Blog |  Igor Cardoso
</title>
</head>

<body class="bg-zinc-950 text-zinc-50 antialiased">
  <!-- Top nav bar -->
  
<nav id="header" class="w-full z-10 top-0 shadow-md mx-0">
  <div id="progress" class="top-0"></div>
  <!-- <div class="w-full max-w-5xl mx-auto flex flex-wrap items-center justify-between mt-0 py-2  sm:bg-green-900 md:bg-red-900 lg:bg-blue-900 bg-yellow-900"> -->
  <div class="w-full max-w-4xl mx-auto flex sm:flex-nowrap flex-wrap items-center justify-between mt-0 py-2">
    <div class="pl-4">
      <a class="text-base no-underline hover:no-underline font-extrabold" href="https:&#x2F;&#x2F;igorgcardoso.github.io/">
        Igor Cardoso
      </a>
    </div>

    <div class="w-full flex-grow sm:flex sm:items-center flex-wrap sm:flex-nowrap sm:w-auto mt-2 sm:mt-0 bg-transparent z-20" id="nav-content">
      <ul class="list-reset flex flex-wrap sm:justify-end flex-1 items-center">
          <li class="mr-3 text-sm">
              <a href="https://igorgcardoso.github.io/projects" class="inline-block text-gray-600 no-underline hover:text-gray-400 hover:text-underline py-2 px-4">
                Projetos
              </a>
            </li>
            <li class="mr-3 text-sm">
              <a href="https://igorgcardoso.github.io/blog" class="inline-block py-2 px-4 text-sky-600 font-bold no-underline">
                Blog
              </a>
            </li>
            <li class="mr-3 text-sm">
            <a href=https://igorgcardoso.github.io/#contact class="inline-block text-gray-600 no-underline hover:text-gray-400 hover:text-underline py-2 px-4">
              Contato
            </a>
          </li>
          <li class="mr-3 text-sm">
              <a href="/en/" class="inline-block text-gray-600 no-underline hover:text-gray-400 hover:text-underline py-2 px-4">en</a>
            </li>
            </ul>
    </div>
  </div>
</nav>

  <!-- Container -->
  
<div class="container max-w-3xl mx-auto px-4">
    <div class="pt-8 flex">
        <h1 class="grow font-bold font-sans break-normal text-3xl">
            Divisão de Equipes Hierárquicas
        </h1>
        
        <p class="text-sm md:text-base font-normal text-gray-600 py-2">
            Publicado 28 de agosto, 2024
        </p>
        
    </div>
    <hr class="border-b-1 border-gray-600 mb-8" />
    <article class="prose prose-invert prose-indigo max-w-3xl pb-40">
         <p>Vamos ver qual é o problema e como podemos resolvê-lo com grafos.</p>
<h2 id="problema">Problema</h2>
<p>Em uma empresa multinacional, os funcionários têm uma hierarquia bem definida. Na empresa, há k funcionários (com IDs entre 1 e k), e cada funcionário pode ter até um chefe imediato (que nunca é ele mesmo). Um funcionário A é considerado de uma hierarquia superior a B se A é o chefe imediato de B ou se A é o chefe imediato de algum funcionário C, que está em uma hierarquia superior a B.</p>
<p>Na hierarquia de funcionários, na empresa não há ciclos (ou seja, não pode acontecer algo como: A ser chefe de B, B ser chefe de C e C ser chefe de A).</p>
<p>Para melhorar a gestão dos recursos humanos e evitar conflitos entre os funcionários, o departamento de RH decidiu dividir os funcionários em grupos de trabalho. A condição é que, em cada grupo, não devem existir dois funcionários onde um está em uma hierarquia superior ao outro.</p>
<p>Quantos grupos de trabalho serão necessários para abrigar todos os funcionários, seguindo a condição explicada acima?</p>
<h2 id="entrada">Entrada</h2>
<p>A primeira linha contém um inteiro k (1 ≤ k ≤ 3000) — o número de funcionários. As próximas k linhas contêm inteiros ci (1 ≤ ci ≤ k ou ci = -1). Cada ci indica o funcionário em uma hierarquia imediatamente acima do i-ésimo funcionário. Se ci for -1, então o i-ésimo funcionário não possui nenhum chefe acima dele.</p>
<h2 id="saida">Saída</h2>
<p>Imprima o número de grupos de trabalho que serão necessários para abrigar todos os funcionários seguindo a condição explicada acima.</p>
<h2 id="exemplo">Exemplo</h2>
<p>Entrada</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>6
</span><span>-1
</span><span>1
</span><span>4
</span><span>1
</span><span>-1
</span><span>-1
</span></code></pre>
<p>Saída</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>3
</span></code></pre>
<h2 id="resolucao">Resolução</h2>
<h3 id="modelagem">Modelagem</h3>
<p>Como podemos resolver este problema com grafos? Primeiramente, vamos entender como modelar o problema.</p>
<blockquote>
<p>Em uma empresa multinacional, os funcionários têm uma hierarquia bem definida. Na empresa, há k funcionários (com IDs entre 1 e k), e cada funcionário pode ter até um chefe imediato (que nunca é ele mesmo). Um funcionário A é considerado de uma hierarquia superior a B se A é o chefe imediato de B ou se A é o chefe imediato de algum funcionário C, que está em uma hierarquia superior a B.
Na hierarquia de funcionários não há ciclos (ou seja, não pode acontecer algo como: A ser chefe de B, B ser chefe de C e C ser chefe de A).</p>
</blockquote>
<p>Levando em conta esta descrição, podemos modelar o problema como uma floresta. Onde cada árvore é uma hierarquia de funcionários. É uma floresta porque na descrição não menciona que vai ser conexo, isto é, que vai ter um superior que é chefe de todos os funcionários. Mas que haverá funcionários que não terão chefe. Deste modo, o que temos é várias árvores, podendo ser uma árvore com um único nó.</p>
<h3 id="solucao">Solução</h3>
<blockquote>
<p>Para melhorar a gestão dos recursos humanos e evitar conflitos entre os funcionários, o departamento de RH decidiu dividir os funcionários em grupos de trabalho. A condição é que, em cada grupo, não devem existir dois funcionários onde um está em uma hierarquia superior ao outro.
Quantos grupos de trabalho serão necessários para abrigar todos os funcionários, seguindo a condição explicada acima?</p>
</blockquote>
<p>Tendo há modelagem, o que precisamos fazer é contar a altura das árvores. A resposta para o nosso problema é a altura da maior árvore. Porque não queremos funcionários que estão na mesma hierarquia em um mesmo grupo.</p>
<h3 id="implementacao">Implementação</h3>
<p>Vamos implementar a solução em Rust.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::collections::{HashMap, HashSet};
</span><span>
</span><span style="color:#65737e;">/// calcula a altura da árvore
</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">get_height</span><span>(</span><span style="color:#bf616a;">trees</span><span>: &amp;HashMap&lt;</span><span style="color:#b48ead;">i32</span><span>, Vec&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;&gt;, </span><span style="color:#bf616a;">start</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; </span><span style="color:#b48ead;">u32 </span><span>{
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> visited = HashSet::new();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> highest_height = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> stack = vec![(start, </span><span style="color:#d08770;">1</span><span>)];
</span><span>    </span><span style="color:#b48ead;">while let </span><span>Some((member, height)) = stack.</span><span style="color:#96b5b4;">pop</span><span>() {
</span><span>        </span><span style="color:#b48ead;">if</span><span> height &gt; highest_height {
</span><span>            highest_height = height;
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">if </span><span>!visited.</span><span style="color:#96b5b4;">contains</span><span>(&amp;member) {
</span><span>            visited.</span><span style="color:#96b5b4;">insert</span><span>(member);
</span><span>            </span><span style="color:#b48ead;">for</span><span> child in trees.</span><span style="color:#96b5b4;">get</span><span>(&amp;(member as </span><span style="color:#b48ead;">i32</span><span>)).</span><span style="color:#96b5b4;">unwrap_or</span><span>(&amp;Vec::new()) {
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>((*child, height + </span><span style="color:#d08770;">1</span><span>));
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    highest_height
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// lê o número de capivaras
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> input = String::new();
</span><span>    std::io::stdin().</span><span style="color:#96b5b4;">read_line</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> input).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> num_members = input.</span><span style="color:#96b5b4;">trim</span><span>().parse::&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// lê os superiores de cada capivara
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> superiors = Vec::with_capacity(num_members);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> input = String::new();
</span><span>    </span><span style="color:#b48ead;">for </span><span>_ in </span><span style="color:#d08770;">0</span><span>..num_members {
</span><span>        std::io::stdin().</span><span style="color:#96b5b4;">read_line</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> input).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>        </span><span style="color:#b48ead;">let</span><span> member = input.</span><span style="color:#96b5b4;">trim</span><span>().parse::&lt;</span><span style="color:#b48ead;">i32</span><span>&gt;().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>        superiors.</span><span style="color:#96b5b4;">push</span><span>(member);
</span><span>        input.</span><span style="color:#96b5b4;">clear</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// cria a floresta
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> trees: HashMap&lt;</span><span style="color:#b48ead;">i32</span><span>, Vec&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;&gt; = HashMap::new();
</span><span>    </span><span style="color:#b48ead;">for </span><span>(member, superior) in superiors.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>        trees
</span><span>            .</span><span style="color:#96b5b4;">entry</span><span>(*superior)
</span><span>            .</span><span style="color:#96b5b4;">or_insert</span><span>(Vec::new())
</span><span>            .</span><span style="color:#96b5b4;">push</span><span>(member + </span><span style="color:#d08770;">1</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// calcula a altura da maior árvore
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> max_height = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">for</span><span> member in trees[&amp;-</span><span style="color:#d08770;">1</span><span>].</span><span style="color:#96b5b4;">clone</span><span>() {
</span><span>        </span><span style="color:#b48ead;">let</span><span> height = </span><span style="color:#96b5b4;">get_height</span><span>(&amp;trees, member);
</span><span>        </span><span style="color:#b48ead;">if</span><span> height &gt; max_height {
</span><span>            max_height = height;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, max_height);
</span><span>}
</span></code></pre>
<p>Após termos esse código base, podemos refatorar ele removendo um loop, que é desnecessário. Vamos fazer isso.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::collections::{HashMap, HashSet};
</span><span>
</span><span style="color:#65737e;">/// calcula a altura da árvore
</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">get_height</span><span>(</span><span style="color:#bf616a;">trees</span><span>: &amp;HashMap&lt;</span><span style="color:#b48ead;">i32</span><span>, Vec&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;&gt;, </span><span style="color:#bf616a;">start</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; </span><span style="color:#b48ead;">u32 </span><span>{
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> visited = HashSet::new();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> highest_height = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> stack = vec![(start, </span><span style="color:#d08770;">1</span><span>)];
</span><span>    </span><span style="color:#b48ead;">while let </span><span>Some((member, height)) = stack.</span><span style="color:#96b5b4;">pop</span><span>() {
</span><span>        </span><span style="color:#b48ead;">if</span><span> height &gt; highest_height {
</span><span>            highest_height = height;
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">if </span><span>!visited.</span><span style="color:#96b5b4;">contains</span><span>(&amp;member) {
</span><span>            visited.</span><span style="color:#96b5b4;">insert</span><span>(member);
</span><span>            </span><span style="color:#b48ead;">for</span><span> child in trees.</span><span style="color:#96b5b4;">get</span><span>(&amp;(member as </span><span style="color:#b48ead;">i32</span><span>)).</span><span style="color:#96b5b4;">unwrap_or</span><span>(&amp;Vec::new()) {
</span><span>                stack.</span><span style="color:#96b5b4;">push</span><span>((*child, height + </span><span style="color:#d08770;">1</span><span>));
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    highest_height
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// lê o número de capivaras
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> input = String::new();
</span><span>    std::io::stdin().</span><span style="color:#96b5b4;">read_line</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> input).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> num_members = input.</span><span style="color:#96b5b4;">trim</span><span>().parse::&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// cria a floresta
</span><span>    </span><span style="color:#65737e;">// nesta versão criamos a floresta simultaneamente com a leitura
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> trees: HashMap&lt;</span><span style="color:#b48ead;">i32</span><span>, Vec&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;&gt; = HashMap::new();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> input = String::new();
</span><span>    </span><span style="color:#b48ead;">for</span><span> member_idx in </span><span style="color:#d08770;">0</span><span>..num_members {
</span><span>        std::io::stdin().</span><span style="color:#96b5b4;">read_line</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> input).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>        </span><span style="color:#b48ead;">let</span><span> superior = input.</span><span style="color:#96b5b4;">trim</span><span>().parse::&lt;</span><span style="color:#b48ead;">i32</span><span>&gt;().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>        trees
</span><span>            .</span><span style="color:#96b5b4;">entry</span><span>(superior)
</span><span>            .</span><span style="color:#96b5b4;">or_insert</span><span>(Vec::new())
</span><span>            .</span><span style="color:#96b5b4;">push</span><span>(member_idx + </span><span style="color:#d08770;">1</span><span>);
</span><span>        input.</span><span style="color:#96b5b4;">clear</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// calcula a altura da maior árvore
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> max_height = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">for</span><span> member in trees[&amp;-</span><span style="color:#d08770;">1</span><span>].</span><span style="color:#96b5b4;">clone</span><span>() {
</span><span>        </span><span style="color:#b48ead;">let</span><span> height = </span><span style="color:#96b5b4;">get_height</span><span>(&amp;trees, member);
</span><span>        </span><span style="color:#b48ead;">if</span><span> height &gt; max_height {
</span><span>            max_height = height;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, max_height);
</span><span>}
</span></code></pre>
 </article>
</div>
<!-- <div class="sticky bottom-0 px-3">
    <a href="#page-top">Back to top of page</a>
  </div> -->
</body>

</html>
